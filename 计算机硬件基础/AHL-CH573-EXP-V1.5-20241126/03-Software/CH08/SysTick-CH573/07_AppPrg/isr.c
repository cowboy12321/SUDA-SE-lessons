//=====================================================================
// 文件名称：isr.c（中断处理程序源文件）
// 框架提供：苏大嵌入式（sumcu.suda.edu.cn）
// 更新记录：20230914
// 功能描述：提供中断处理程序编程框架
// 移植规则：【固定】
//=====================================================================
#include <includes.h>
void SecAdd1(uint8_t *p);
//======================================================================
// 程序名称：UART_User_Handler
// 触发条件：UART_User串口收到一个字节触发
// 备   注：进入本程序后，可使用uart_get_re_int函数可再进行中断标志判断
//          （1-有UART接收中断，0-没有UART接收中断）
//======================================================================
void UART_User_Handler(void)
{
    //【1】关中断
    DISABLE_INTERRUPTS;

    //【2】声明临时变量
    uint8_t flag,ch;

    //【3】判断是否为本中断触发
    if (!uart_get_re_int(UART_User)) goto UART_User_Handler_exit;

    //【4】确证是本中断触发，读取接到的字节赋给变量ch，flag是收到数据标志
    ch=uart_re1(UART_User,&flag);   //调用接收一个字节的函数，清接收中断位

    //【5】根据flag判断是否真正收到一个字节的数据
    if (flag)                       //有数据
    {
        uart_send1(UART_User,ch);   //回发接收到的字节
    }

    // 【6】开中断
UART_User_Handler_exit:
    ENABLE_INTERRUPTS;
}

//=====================================================================
//程序名称：SysTick_Handler（SysTick定时器中断服务例程）
//触发条件：SysTick定时器每10ms触发一次
//功能概要：（1）每10ms中断触发本程序一次；
//         （2）达到一秒时，调用秒+1程序，计算“时、分、秒”
//特别提示：（1）使用全局变量字节型数组gTime[3]，分别存储“时、分、秒”
//          （2）注意其中静态变量的使用
//=====================================================================
void SysTick_Handler()
{
	//【1】关中断
    DISABLE_INTERRUPTS;
    //【2】声明静态变量（10ms单元）
	static uint8_t SysTickCount = 0;
	//【3】清中断标志
	systick_clear_int(); 
	//【4】10ms单元+1
	SysTickCount++;   
	//【5】1s到处理
	if (SysTickCount >= 100)
	{
		SysTickCount = 0;
		SecAdd1(gTime);  //调用秒+1函数
	}
}

//===========================================================================
//函数名称：SecAdd1（秒+1函数）
//函数返回：无
//参数说明：*p:为指向一个时分秒数组p[3]
//功能概要：秒单元+1，并处理时分单元（00:00:00-23:59:59)
//===========================================================================
void SecAdd1(uint8_t *p)
{
	//【1】秒+1
	*(p+2)+=1;  
	//【2】没到1分钟，退出
	if (*(p+2)<60) goto SecAdd1_Exit;
	//【3】到1分钟
    *(p+2)=0;       //清秒
	*(p+1)+=1;      //分+1
	//【4】没到1小时，退出
	if (*(p+1)<60) goto SecAdd1_Exit;
	//【5】到1小时
	*(p+1)=0;      //清分
	*p+=1;         //时+1
	//【6】没到1天，退出
	if (*p<24)  goto SecAdd1_Exit;
	//【7】到1天
	*p=0;         //清时
SecAdd1_Exit:
    __asm ("nop");
}
